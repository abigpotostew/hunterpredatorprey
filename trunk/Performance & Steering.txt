Performance:
	As for speed, we had no direct way of measuring how long each individual AI piece took to update. However, to account for this setback, we changed the framerate of our game to test performance impact. By default our game runs at 60 fps. At 100 frames per second, the game did not lag at all. At this rate, the game has 10 milliseconds per frame to update all the AI. Increasing the framerate to 500 fps sped up the gameplay, but also had no performance impact. At 500fps all of the AI has 2 milliseconds up update. Continuing, at 1000fps the game has 1ms to update all AI each frame. The game showed small signs of lag, but for the most part it still ran. This mean that each frame, our AI updates and executes in less than or equal to 1 millisecond. Normally AI is a small part of a larger game. I'd assume that 1ms is a reasonable amount of time dedicated to AI. In conclusion, our AI is efficient.


Steering:
	Steering was a task implementing. However the result was very elegant when it all came together. Steering behavior classes all extend a steering interface, which has three overloads to the getSteering() method which always returns a SteeringOutout struct which simply contains the linear and angular change calculated by the particular steering class for the entity calling getSteering(). The best part about my implementation is that SteeringOutputs can be strung together. For example, a deer during flocking will string together getSteering() calls from spearation, cohesion, and velocity match using the + operator that I overloaded to add the linear values and angular values together.
	Each Action returned by the FSM and HFSM Update()s returns a string together SteeringOutput which is passed down to the Entity physics engine that adds the appropriate linear and angular values and caps them by the patricular Entities MaxSpeed & Acceleration. Stringing together the flocking actions all combine into one single SteeringOutput at the base Entity level which finally applies those changes to the position and orienation of the entity.
	I experiemented with many different steering behaviors during development, but the final release contains 13 unique steering behaviors, some of which extend other steering behaviors. Most of these steering behaviors accept a character representing the entity being changed, and a target which is where the steering will base calculations on. However, some steering behaviors, such as when implementing flocking, require a list of targets. Convienently the getSteering() method has overloads to run with parameters:
	1. Just a character (LookWhereYourGoing, Wander)
	2. Character & single target (Align, Arrive, Cohesion, Face, Flee, Pursue, Seek, Separation, Velocity Match)
	3. Character & List of targets (Arrive, Cohesion, Flee, Separation, Velocity Match)
	This is where I departed from the book's implementation a bit. The book creates a new Steering class for each steering a particular entity will use and links it directly with that one entity and it's target. For our game, it seemed unreasonable to create 40 different Wander behaviors for each of the 40 deer. I wanted something more dynamic and general purpose and less memory heavy. So I created a public and static Steerings Blackboard that any entity or action in the game can access. This way, there exists one wander for all deer, one lookWhereYourGoing for everyone, etc.
	Our group was very happy with the way the steering turned out, most of the behaviors were smooth and nice to watch, especially the deer flocking. The biggest problem I had is that I could not figure out how to make wander work well. In the release, when the lion or any deer wander they usually twitch quite a bit. When I tweaked the wander variables at all the wander behavior would usually stop working completely. I think it's a deeper problem with the random values being generated because I know I coded the wander behavior correctly.
	