Performance:
	As for speed, we had no direct way of measuring how long each individual AI piece took to update. However, to account for this setback, we changed the framerate of our game to test performance impact. By default our game runs at 60 fps. At 100 frames per second, the game did not lag at all. At this rate, the game has 10 milliseconds per frame to update all the AI. Increasing the framerate to 500 fps sped up the gameplay, but also had no performance impact. At 500fps all of the AI has 2 milliseconds up update. Continuing, at 1000fps the game has 1ms to update all AI each frame. The game showed small signs of lag, but for the most part it still ran. This mean that each frame, our AI updates and executes in less than or equal to 1 millisecond. Normally AI is a small part of a larger game. I'd assume that 1ms is a reasonable amount of time dedicated to AI. In conclusion, our AI is efficient.


Steering:
	Steering was a task implementing. However the result was very elegant when it all came together. Steering classes all extend a steering interface, which has three overloads to the getSteering method which always returns a SteeringOutout struct which simply contains the linear and angular change for the entity calling getSteering(). The best part about my implementation is that SteeringOutputs can be strung together. For example, a deer during flocking will string together getSteering() calls from spearation, cohesion, and velocity match using the + operator that I overloaded to add the linear values and angular values together.
	Each Action returned by the FSM and HFSM Update()s return a SteeringOutput which is passed down to the Entity physics engine that adds the appropriate linear and angular values and caps them by the patricular Entities MaxSpeed & Acceleration.